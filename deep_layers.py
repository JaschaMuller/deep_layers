# -*- coding: utf-8 -*-
"""
/***************************************************************************
 deepLayers
                                 A QGIS plugin
 Data management plugin for deep layers
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-05-30
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Jascha Muller
        email                : jascha.muller@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import (
    QSettings, 
    QTranslator, 
    QCoreApplication, 
    Qt, 
    QObject, 
    QVariant, 
    pyqtSignal, 
    QRunnable, 
    pyqtSlot, 
    QThreadPool, 
    QDateTime
)
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import (
    QAction, 
    QFileDialog, 
    QMainWindow, 
    QMessageBox, 
    QTableWidgetItem, 
    QPushButton, 
    QDialog, 
    QApplication, 
    QGridLayout, 
    QVBoxLayout,
    QHBoxLayout, 
    QDialogButtonBox,
    QDateEdit, 
    QLabel,
    QComboBox)
from qgis.core import (
    QgsVectorLayer,
    QgsPoint,
    QgsPointXY,
    QgsProject,
    QgsGeometry,
    QgsMapRendererJob,
    QgsFeatureRequest,
    QgsCoordinateReferenceSystem,
    QgsRectangle,
    QgsWkbTypes,
    QgsField,
    QgsSymbol,
    QgsSimpleFillSymbolLayer,
    QgsRendererCategory,
    QgsCategorizedSymbolRenderer,
) 

from qgis.gui import (
    QgsMapToolPan, 
    QgsMapToolZoom, 
    QgsMapCanvas,
    QgsMapToolEmitPoint,
    QgsRubberBand,
    QgsMapTool,
    QgsMapToolIdentifyFeature
)

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .deep_layers_dialog import deepLayersDialog
import os
import os.path
import traceback
import sys
import pathlib
import numpy as np
import pandas as pd
import shapely
from subprocess import Popen, PIPE, check_output, STDOUT, CREATE_NO_WINDOW
import time

try:
    from eolearn.core import FeatureType, EOPatch, LoadTask, OverwritePermission
    from eolearn.io import ExportToTiff
    from sentinelhub import BBoxSplitter, CRS, BBox
except:
    import osgeo.gdal
    gdalvnum =  osgeo.gdal.__version__

    #get raterio and fional wheel for installation
    __location__ = os.path.realpath(os.path.join(os.getcwd(), 
                                    os.path.dirname(__file__)))
    raswhl = os.path.join(__location__, 
    'resources/rasterio-1.0.28-cp37-cp37m-win_amd64.whl')
    fiowhl = os.path.join(__location__, 
    'resources/Fiona-1.8.13-cp37-cp37m-win_amd64.whl')
    pythonPath = str(pathlib.Path(sys.executable).parent/'py3_env.bat')
    commands ='call '+pythonPath + '\n\
               set GDAL_VERSION='+gdalvnum+'\n\
               set GDAL_VERSION\n\
               pip install '+raswhl+'\n\
               pip install '+fiowhl+'\n\
               pip install eo-learn\n'
    process = Popen("cmd.exe", shell=False, universal_newlines=True,
                  stdin=PIPE, stdout=PIPE, stderr=PIPE )                             
    
    # print out and err for debugging
    out, err = process.communicate(commands)
    print('OUT->', out)
    print('ERR->', err)
    from eolearn.core import FeatureType, EOPatch, LoadTask, OverwritePermission
    from eolearn.io import ExportToTiff
    from sentinelhub import BBoxSplitter, CRS, BBox
try:
    import sentinelsat
except:
    commands ='call '+pythonPath + '\n\
               pip install sentinelsat\n'
    process = Popen("cmd.exe", shell=False, universal_newlines=True,
                  stdin=PIPE, stdout=PIPE, stderr=PIPE )                             
    
    # print out and err for debugging
    out, err = process.communicate(commands)
    # Also geopandas is important
    import sentinelsat
try:
    import rasterio
except:
    commands ='call '+pythonPath + '\n\
               pip install rasetrio\n'
    process = Popen("cmd.exe", shell=False, universal_newlines=True,
                  stdin=PIPE, stdout=PIPE, stderr=PIPE )                             
    
    # print out and err for debugging
    out, err = process.communicate(commands)
    # Also geopandas is important
    import rasterio 
try:
    import geopandas
except:
    commands ='call '+pythonPath + '\n\
               pip install geopandas\n'
    process = Popen("cmd.exe", shell=False, universal_newlines=True,
                  stdin=PIPE, stdout=PIPE, stderr=PIPE )                             
    
    # print out and err for debugging
    out, err = process.communicate(commands)
    # Also geopandas is important
    import geopandas 


#import importlib.util
#spec = importlib.util.spec_from_file_location("s2api.dwnl", os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))+'\sentinelsatAPI.py')
#s2api = importlib.util.module_from_spec(spec)
#spec.loader.exec_module(s2api)
CREATE_NO_WINDOW = 0x08000000


class DownloadS2(QDialog):

    def __init__(self):
        super(DownloadS2, self).__init__()
        
        self.setWindowTitle('Select S-2 parameters')
     
        self.startDateLbl = QLabel('Please select start date:')
        self.startdateedit = QDateEdit(calendarPopup=True)
        self.startdateedit.setDateTime(QDateTime.currentDateTime())
        self.endDateLbl = QLabel('Please select end date:')
        self.enddateedit = QDateEdit(calendarPopup=True)
        self.enddateedit.setDateTime(QDateTime.currentDateTime())
        self.CloudLbl = QLabel('Please select max cloud cover:')
        self.CloudList = QComboBox()
        self.CloudList.addItems(['0','10','20','30','40','50','60','70','80','90','100'])

        self.okbutton = QPushButton("OK")
        self.cancelButton =QPushButton("Cancel")
        
        self.hboxlayout_start = QHBoxLayout()
        self.hboxlayout_start.addWidget(self.startDateLbl)
        self.hboxlayout_start.addWidget(self.startdateedit)

        self.hboxlayout_end = QHBoxLayout()
        self.hboxlayout_end.addWidget(self.endDateLbl)
        self.hboxlayout_end.addWidget(self.enddateedit)

        self.hboxlayout_clouds = QHBoxLayout()
        self.hboxlayout_clouds.addWidget(self.CloudLbl)
        self.hboxlayout_clouds.addWidget(self.CloudList)

        self.hboxlayout_final = QHBoxLayout()
        self.hboxlayout_final.addWidget(self.okbutton)
        self.hboxlayout_final.addWidget(self.cancelButton)

        self.layout = QVBoxLayout()
        self.layout.addLayout(self.hboxlayout_start)
        self.layout.addLayout(self.hboxlayout_end)
        self.layout.addLayout(self.hboxlayout_clouds)
        self.layout.addLayout(self.hboxlayout_final)

        self.setLayout(self.layout)

        self.okbutton.clicked.connect(self.on_accept)
        self.cancelButton.clicked.connect(self.on_reject)

        self.returnDict=dict()

    def on_accept(self):
        self.returnDict['startDate'] = self.startdateedit.date().toPyDate()
        self.returnDict['endDate'] = self.enddateedit.date().toPyDate()
        self.returnDict['maxc'] = self.CloudList.currentText()
        self.accept()

    def on_reject(self):
        self.reject()

    def get_data(self):
        return self.returnDict
        
        #layout = QGridLayout()
        #self.but_ok = QPushButton(text)
        #layout.addWidget(self.but_ok ,1,1)

    #def closeEvent(self, evnt):
    #    super(DownloadS2, self).closeEvent(evnt)
    #    print('close')
        #return 'close'

class WorkerSignals(QObject):

    finished = pyqtSignal()
    error = pyqtSignal(tuple)
    result = pyqtSignal(object)
    progress = pyqtSignal(int)

class Worker(QRunnable):
    
    def __init__(self, fn, *args, **kwargs):
            super(Worker, self).__init__()

            # Store constructor arguments (re-used for processing)
            self.fn = fn
            self.args = args
            self.kwargs = kwargs
            self.signals = WorkerSignals()    

            # Add the callback to our kwargs
            self.kwargs['progress_callback'] = self.signals.progress        

    @pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''
        
        # Retrieve args/kwargs here; and fire processing using them
        try:
            result = self.fn(*self.args, **self.kwargs)
        except:
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            self.signals.finished.emit()  # Done


class deepLayers:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'deepLayers_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&deep layers')

        # Load Vector Layers
        #------------------------------------------------------
        self.__location__ = os.path.realpath(os.path.join(os.getcwd(), 
                                    os.path.dirname(__file__)))
        worldBorders = os.path.join(self.__location__, 'resources\world_borders.shp')
        self.worldB = QgsVectorLayer(worldBorders, "World Borders", "ogr")
        # Check if vector Layer exists
        if not self.worldB.isValid():
            print("world layer failed to load!")
        
        s2Grid = os.path.join(self.__location__, 'resources\S2_mgrs_world.shp')
        self.S2g = QgsVectorLayer(s2Grid, "S2 grid", "ogr")
        if not self.S2g.isValid():
            print("s2 layer failed to load!")
        
        # Initiate study area gird variable
        #------------------------------------------------------
        self.NowS2={'status':False,
                    'layer':None,
                    'selection':False,
                    'GridName':None}
        self.eoPatches={'status':False,
                        'layer':None,
                        'connected':False}
        self.eopDir_workspace={'path':None}

        self.NowS2Grids={'status':False,
                         'path':None,
                         'blocks':[]}
        
        self.s2_dwnld_args=dict()

        self.threadpool = QThreadPool()
        #------------------------------------------------------

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('deepLayers', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/deep_layers/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'deep layers'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&deep layers'),
                action)
            self.iface.removeToolBarIcon(action)

    def execute_this_fn(self, progress_callback):
        # Download function here

        
        userName = 'jaschamuller'
        pswrd = 'ESAOPENCLOUD'
        '''
        dwnld = s2api.s2Dwnld(userName, pswrd, ['34HDK'], ['2019-01-01', '2019-01-30'], 80)
        #s2api.createPatches(dwnld, 'E:/1_Geography_Systems/eopatches','C:/S2dwnld/')
        #progress_callback.emit(s2api.mock_function(5,progress_callback))
        progress_callback.emit(s2api.createPatches(dwnld, 'E:/1_Geography_Systems/eopatches',tempDir= 'C:/S2dwnld/',_callback=progress_callback))
        
        #for n in range(0, 5):
        #    time.sleep(5)
        #    progress_callback.emit(n*100/4)
        '''
        argsFile = [userName, pswrd, 
                    self.NowS2['GridName'],
                    self.s2_dwnld_args['startDate'],
                    self.s2_dwnld_args['endDate'], 
                    str(self.s2_dwnld_args['maxc'])]

        print('Passing arguments here: ', argsFile)
        fileToRun = [self.__location__ + "/sentinelsatAPI.py"]
        #Popen(["python "+ fileToRun + argsFile])

        
        p = Popen(["python "]+ fileToRun + argsFile,
                            stdout=PIPE,
                            stderr=PIPE,
                            creationflags=CREATE_NO_WINDOW)

        output, error = p.communicate()
        if p.returncode != 0: 
            print("failed %d %s %s" % (p.returncode, output, error))

        return "Done."
    
    def progress_fn(self, n):
        #update progressbar here
        print("%d%% done" % n)
        self.dlg.progressBar.setValue(n)
    
    def print_output(self, s):
        print(s)

    def thread_complete(self):
        msg = QMessageBox()
        msg.setWindowTitle('Info')
        msg.setText('S-2 download for the specified grid and time is done')
        msg.setIcon(QMessageBox.Information)
        msg.exec_()

        self.dlg.progressBar.hide()
        #print("THREAD COMPLETE!")

    
    def spinThread(self):

        worker = Worker(self.execute_this_fn)
        worker.signals.result.connect(self.print_output)
        worker.signals.finished.connect(self.thread_complete)
        worker.signals.progress.connect(self.progress_fn)
        # Execute
        self.threadpool.start(worker)
    
    def launchS2Dwnld(self):
        
        win = DownloadS2()
        if win.exec_():
            print('Accepted bru... calling download script here')
            s2_agruments = win.get_data()
            self.s2_dwnld_args.clear()
            self.s2_dwnld_args.update(s2_agruments)
            self.s2_dwnld_args['startDate'] = self.s2_dwnld_args['startDate'].strftime("%Y-%m-%d")
            self.s2_dwnld_args['endDate'] = self.s2_dwnld_args['endDate'].strftime("%Y-%m-%d")
            self.s2_dwnld_args['maxc'] = int(self.s2_dwnld_args['maxc'])

            print('Here is the info:', self.s2_dwnld_args)
            #self.dlg.progressBar.setVisible(True)
            #self.dlg.progressBar.setValue(0)
            self.spinThread()
        else:
            print('Not accepted... OK')

    
    
    def select_eopdir(self):

        eopDir = str(QFileDialog.getExistingDirectory(self.dlg, "Select Directory"))
        
        #eopDir_workspace = pathlib.Path(eopDir)
        self.eopDir_workspace['path'] = pathlib.Path(eopDir)
        activeGridPaths = [x for x in self.eopDir_workspace['path'].iterdir() if x.is_dir()]
        activeGridNames = [y.name for y in activeGridPaths]
        print(activeGridNames)
        self.eoPatches['status']=True
        self.eoPatches['layer']=activeGridPaths
                    
        if self.NowS2['status'] == True:
            
            nowNames = self.NowS2['layer'].fields().names()
            print('Here:', nowNames)
            if 'eopatch' not in nowNames:
                layer_provider=self.NowS2['layer'].dataProvider()
                layer_provider.addAttributes([QgsField("eopatch",QVariant.Int)])
                self.NowS2['layer'].updateFields()
            else:
                layer_provider=self.NowS2['layer'].dataProvider()

            nowNames = np.array(self.NowS2['layer'].fields().names())
            grdnmidx = list(np.where(nowNames=='name'))[0][0]
            eopidx = list(np.where(nowNames=='eopatch'))[0][0]

            print('Index', eopidx)
            #field = layer.fieldNameIndex(fieldName) 
            
            features=self.NowS2['layer'].getFeatures()
            self.NowS2['layer'].startEditing()
            for f in features:
                featureId=f.id()
                gridname=f.attributes()[grdnmidx]
                if gridname in activeGridNames:
                    attr_value={eopidx:1}
                    layer_provider.changeAttributeValues({featureId:attr_value})
                else:
                    attr_value={eopidx:0}
                    layer_provider.changeAttributeValues({featureId:attr_value})

            self.NowS2['layer'].commitChanges()     
            
            categories=[]
            
            # initialize the default symbol for this geometry type
            symbol = QgsSymbol.defaultSymbol(self.NowS2['layer'].geometryType())

            symbol.setColor(QColor("Transparent"))
            category = QgsRendererCategory(0, symbol, str(0))
            categories.append(category)
            
            # initialize the default symbol for this geometry type
            symbol = QgsSymbol.defaultSymbol(self.NowS2['layer'].geometryType())
            layer_style = {}
            layer_style['color'] = '%d, %d, %d' % (255,192,0)
            layer_style['outline'] = '#000000'
            symbol_layer = QgsSimpleFillSymbolLayer.create(layer_style)

            # replace default symbol layer with the configured one
            if symbol_layer is not None:
                symbol.changeSymbolLayer(0, symbol_layer)
            # create renderer object
            #symbol.setOpacity(0.7)
            category = QgsRendererCategory(1, symbol, str(1))
            # entry for the list of category items
            categories.append(category)
            # create renderer object
            renderer = QgsCategorizedSymbolRenderer('eopatch', categories)
            # assign the created renderer to the layer
            if renderer is not None:
                self.NowS2['layer'].setRenderer(renderer)

            self.NowS2['layer'].triggerRepaint()
            
            #renderer = self.NowS2['layer'].renderer()
            #current_symbol = renderer.symbol()
            #new_symbol = current_symbol.clone()
            #new_symbol.setColor(QColor("Transparent"))
            #renderer.setSymbol(new_symbol)
            
            
            self.eoPatches['connected'] = True
        
        self.dlg.lineEdit.setText(eopDir)
        print('Done here bro')

    def zoomToSelection(self):
        
        if self.dlg.comboBox.currentIndex() == -1:
            pass
        else:
            if self.NowS2['status'] == True:
                QgsProject.instance().removeMapLayer(self.NowS2['layer'])
                self.NowS2['status'] = False

            selectedCountry = str(self.dlg.comboBox.currentText())
            self.worldB.selectByExpression("\"CNTRY_NAME\"='%s'"%(selectedCountry))

            selectedCountries = self.worldB.selectedFeatures()
            to_select=[]
            for country in selectedCountries:
                for s2gridfeat in self.S2g.getFeatures():
                    if country.geometry().intersects(s2gridfeat.geometry()):
                        to_select.append(s2gridfeat.id())
            #self.S2g.setSelectedFeatures(to_select)
            self.S2g.selectByIds(to_select)
            box = self.S2g.boundingBoxOfSelected()
            self.dlg.MyMapCanvas.setExtent(box)
            self.dlg.MyMapCanvas.refresh()

            self.NowS2['layer'] = self.S2g.materialize(QgsFeatureRequest()\
                                    .setFilterFids(self.S2g.selectedFeatureIds()))
            self.NowS2['status'] = True
            QgsProject.instance().addMapLayer(self.NowS2['layer'])
            self.iface.mapCanvas().setExtent(box)
            self.iface.mapCanvas().refresh()
        
            renderer = self.NowS2['layer'].renderer()
            current_symbol = renderer.symbol()
            new_symbol = current_symbol.clone()
            new_symbol.setColor(QColor("Transparent"))
            renderer.setSymbol(new_symbol)
            
            #self.dlg.MyMapCanvas.setLayers([self.S2g, self.worldB])
            self.dlg.MyMapCanvas.setLayers([self.NowS2['layer'], self.worldB])
            self.worldB.removeSelection()
            self.dlg.MyMapCanvas.refresh()

            if self.eoPatches['status'] == True:
                print(self.NowS2['layer'].fields().names())
                print('Do- connection')

            #self.dlg.mapInfo.itemActivated()
            self.dlg.mapInfo.show()

    def pan(self):
        self.dlg.MyMapCanvas.setMapTool(self.dlg.toolPan)

    def select(self):
        
        if self.NowS2['status'] == True:
            self.dlg.toolSelect.setLayer(self.NowS2['layer'])

        self.dlg.MyMapCanvas.setMapTool(self.dlg.toolSelect) 

    def clear_selection(self):
        if self.NowS2['status'] == True:
            self.NowS2['layer'].removeSelection()
            self.NowS2['selection'] = False
            self.NowS2['GridName'] = None
        
        self.dlg.tableWidget.setRowCount(0)
        self.dlg.dwnlS2_btn.setEnabled(False)

    def editItem(self):
        print('editing', item.text())
    
    def load_selection(self):
        print(self.NowS2)
        if self.NowS2['selection'] == False:
            msg = QMessageBox()
            msg.setWindowTitle('Hold on...')
            msg.setText('Please select a S2 grid tile with the select button before you load')
            msg.setIcon(QMessageBox.Critical)
            msg.exec_()

        else:
            #Check if selected tile has any info
            #print(self.NowS2['layer'].selectedFeatureIds())

            info_display=[]
            
            self.dlg.tableWidget.setRowCount(0)

            nowNames = np.array(self.NowS2['layer'].fields().names())
            grdnmidx = list(np.where(nowNames=='name'))[0][0]

            self.NowS2['GridName']=[feat.attributes() for feat in self.NowS2['layer'].selectedFeatures()][0][grdnmidx]
            #SelectedS2 = [feat.attributes() for feat in self.NowS2['layer'].selectedFeatures()][0][grdnmidx]
            info_display.append(['S2 grid: ', self.NowS2['GridName']])
            try:
                eopidx = list(np.where(nowNames=='eopatch'))[0][0]
                Pop_status = [feat.attributes() for feat in self.NowS2['layer'].selectedFeatures()][0][eopidx]
            except:
                Pop_status = 0

            if Pop_status == 0:
                info_display.append(['Populated', 'False'])
            elif Pop_status == 1:
                info_display.append(['Populated', 'True'])
                self.NowS2Grids['status']=True
                self.NowS2Grids['path']=self.eopDir_workspace['path']/self.NowS2['GridName']
                dir_eopathces = os.listdir(self.NowS2Grids['path'])
                dir_eopathces = [[x.split('_')[0], x.split('_')[1],
                                  shapely.geometry.Polygon([[float(x.split('_')[3]),float(x.split('_')[4])],
                                                            [float(x.split('_')[3]),float(x.split('_')[6])],
                                                            [float(x.split('_')[5]),float(x.split('_')[6])],
                                                            [float(x.split('_')[5]),float(x.split('_')[4])]]),
                                  x.split('_')[8]] for x in dir_eopathces]
                eopatchesDF = pd.DataFrame(dir_eopathces, columns=['gird_id', 'patch_id', 'geometry', 'epsg'])
                self.NowS2Grids['blocks'] = eopatchesDF
                
                print(self.NowS2Grids['blocks'])
                # HERE get some information
                
            self.dlg.tableWidget.setColumnCount(2)
            self.dlg.tableWidget.setHorizontalHeaderLabels(['Heading', 'Information'])

            for i in range(len(info_display)):   
                rowPosition = self.dlg.tableWidget.rowCount()
                self.dlg.tableWidget.insertRow(rowPosition)    
                self.dlg.tableWidget.setItem(rowPosition , 0, QTableWidgetItem(str(info_display[i][0])))
                self.dlg.tableWidget.setItem(rowPosition , 1, QTableWidgetItem(str(info_display[i][1])))

        self.dlg.dwnlS2_btn.setEnabled(True)
 
    def onFeatureIdentified(self, feature):
        fid = feature.id()
        print ("feature selected : " + str(fid))

        for layer in self.dlg.MyMapCanvas.layers():
            if layer.type() == layer.VectorLayer:
                layer.removeSelection()
        self.dlg.MyMapCanvas.refresh()
        
        self.NowS2['layer'].select([fid])
        self.dlg.MyMapCanvas.setSelectionColor(QColor("red"))
        self.NowS2['selection'] = True

    def onClose_x(self):
        if self.NowS2['status'] == True:
            QgsProject.instance().removeMapLayers( [self.NowS2['layer'].id()] )
            self.NowS2['status'] = False
            self.NowS2['selection'] = False
            self.NowS2['GridName'] = None
            self.eoPatches['status']=False
            self.eoPatches['connected']=False
    def Quit(self):
        if self.NowS2['status'] == True:
            QgsProject.instance().removeMapLayers( [self.NowS2['layer'].id()] )
            self.NowS2['status'] = False
            self.NowS2['selection'] = False
            self.NowS2['GridName'] = None
            self.eoPatches['status']=False
            self.eoPatches['connected']=False
        self.dlg.close()


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = deepLayersDialog()
            self.dlg.browseButton.clicked.connect(self.select_eopdir)
            self.dlg.loadButton.clicked.connect(self.zoomToSelection)
            self.dlg.panButton.clicked.connect(self.pan)
            self.dlg.selectButton.clicked.connect(self.select)
            self.dlg.clearSelection.clicked.connect(self.clear_selection)
            self.dlg.loadSelection.clicked.connect(self.load_selection)
            self.dlg.dwnlS2_btn.clicked.connect(self.launchS2Dwnld)
            #self.dlg.comboBox.currentIndexChanged.connect(self.zoomToSelection)
            
            self.dlg.rejected.connect(self.onClose_x)
            self.dlg.quit.clicked.connect(self.Quit)
            

        self.dlg.setLayout(self.dlg.gridLayout_2)

        
        #Initiate standard launch settings
        #---------------------------------
        not_resize = self.dlg.mapInfo.sizePolicy()
        not_resize.setRetainSizeWhenHidden(True)
        self.dlg.mapInfo.setSizePolicy(not_resize)
        self.dlg.mapInfo.hide()

        # Clear the contents of the comboBox from previous runs
        self.dlg.comboBox.clear()
        # Populate the comboBox with names of all the loaded layers
        supportedCountries = ['South Africa', 'Germany']
        self.dlg.comboBox.addItems([country for country in supportedCountries])
        # Set place holder text
        self.dlg.comboBox.setEditable(True)
        self.dlg.comboBox.setCurrentIndex(-1)
        self.dlg.comboBox.setCurrentText("Select country ...")

        self.dlg.lineEdit.setText('Select eo-patch folder ...')

        # Change the symbol of vector layer
        self.worldB.removeSelection()
        renderer = self.worldB.renderer()
        current_symbol = renderer.symbol()
        new_symbol = current_symbol.clone()
        new_symbol.setColor(QColor.fromRgb(146,208,80))
        renderer.setSymbol(new_symbol)

        # Add vector layuer to the map canvas
        # add layer to the registry
        #QgsProject.instance().addMapLayer(self.worldB)
        # set extent to the extent of our layer
        self.dlg.MyMapCanvas.setExtent(self.worldB.extent())
        #self.dlg.MyMapCanvas.setSelectionColor(QColor.fromRgb(255,192,0))
        # set the map canvas layer set
        self.dlg.MyMapCanvas.setLayers([self.worldB])
        self.dlg.MyMapCanvas.refresh()

        # Setup pan tool
        self.dlg.toolPan = QgsMapToolPan(self.dlg.MyMapCanvas)
        # Setup select tool
        #self.dlg.toolSelect = RectangleMapTool(self.dlg.MyMapCanvas)
        self.dlg.toolSelect = QgsMapToolIdentifyFeature(self.dlg.MyMapCanvas)
        self.dlg.toolSelect.featureIdentified.connect(self.onFeatureIdentified)

        #Change main qgis map canvas to wgs84
        self.iface.mapCanvas().setDestinationCrs(QgsCoordinateReferenceSystem(4326))
        self.iface.mapCanvas().refresh()

        self.dlg.progressBar.hide()
        

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
